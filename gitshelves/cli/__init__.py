import argparse
import json
import re
import shutil
import sys
from calendar import month_abbr, month_name
from importlib import metadata
from pathlib import Path

from .. import fetch as _fetch
from .. import scad as _scad
from ..baseplate import load_baseplate_scad
from ..core.contributions import build_contribution_maps
from ..core.metadata import MetadataWriter
from ..readme import write_year_readme


SCAD_HEADER = "// Generated by gitshelves"

__all__ = ["main"]

_DEFAULT_FETCH_USER_CONTRIBUTIONS = _fetch.fetch_user_contributions
_DEFAULT_RESOLVE_TOKEN = _fetch.resolve_token
_DEFAULT_DETERMINE_YEAR_RANGE = _fetch._determine_year_range


def _fetch_module():
    return sys.modules.get("gitshelves.fetch", _fetch)


def _scad_module():
    return sys.modules.get("gitshelves.scad", _scad)


def fetch_user_contributions(*args, **kwargs):
    func = getattr(
        _fetch_module(), "fetch_user_contributions", _DEFAULT_FETCH_USER_CONTRIBUTIONS
    )
    return func(*args, **kwargs)


def resolve_token(token: str | None) -> str | None:
    func = getattr(_fetch_module(), "resolve_token", _DEFAULT_RESOLVE_TOKEN)
    return func(token)


def _determine_year_range(start: int | None, end: int | None) -> tuple[int, int]:
    func = getattr(
        _fetch_module(), "_determine_year_range", _DEFAULT_DETERMINE_YEAR_RANGE
    )
    return func(start, end)


def blocks_for_contributions(count: int) -> int:
    return _scad_module().blocks_for_contributions(count)


def generate_contrib_cube_stack_scad(levels: int) -> str:
    return _scad_module().generate_contrib_cube_stack_scad(levels)


def generate_gridfinity_plate_scad(*args, **kwargs) -> str:
    return _scad_module().generate_gridfinity_plate_scad(*args, **kwargs)


def generate_scad_monthly(*args, **kwargs) -> str:
    return _scad_module().generate_scad_monthly(*args, **kwargs)


def generate_scad_monthly_levels(*args, **kwargs) -> dict:
    return _scad_module().generate_scad_monthly_levels(*args, **kwargs)


def generate_monthly_calendar_scads(*args, **kwargs) -> dict:
    return _scad_module().generate_monthly_calendar_scads(*args, **kwargs)


def generate_zero_month_annotations(*args, **kwargs) -> list[str]:
    return _scad_module().generate_zero_month_annotations(*args, **kwargs)


def group_scad_levels(*args, **kwargs) -> dict:
    return _scad_module().group_scad_levels(*args, **kwargs)


def group_scad_levels_with_mapping(*args, **kwargs) -> tuple[dict, dict]:
    scad_mod = _scad_module()
    func = getattr(scad_mod, "group_scad_levels_with_mapping", None)
    if func is None:
        grouped = scad_mod.group_scad_levels(*args, **kwargs)
        mapping = {idx: [] for idx in grouped}
        return grouped, mapping
    return func(*args, **kwargs)


def scad_to_stl(*args, **kwargs) -> None:
    return _scad_module().scad_to_stl(*args, **kwargs)


def _calendar_slug(days_per_row: int) -> str:
    return f"monthly-{days_per_row}x6"


def _write_year_baseplate(
    year_dir: Path, render_stl: bool, metadata_writer: MetadataWriter, year: int
) -> None:
    """Copy the bundled 2Ã—6 baseplate into ``year_dir`` and optionally render an STL."""

    year_dir.mkdir(parents=True, exist_ok=True)
    baseplate_path = year_dir / "baseplate_2x6.scad"
    baseplate_text = load_baseplate_scad("baseplate_2x6.scad")
    baseplate_path.write_text(baseplate_text)
    print(f"Wrote {baseplate_path}")
    if render_stl:
        baseplate_stl = baseplate_path.with_suffix(".stl")
        scad_to_stl(str(baseplate_path), str(baseplate_stl))
        print(f"Wrote {baseplate_stl}")
    else:
        baseplate_path.with_suffix(".stl").unlink(missing_ok=True)
        baseplate_stl = None
    metadata_writer.write_scad(
        baseplate_path,
        kind="year-baseplate",
        stl_path=baseplate_stl,
        year=year,
        monthly_contributions=metadata_writer.monthly_contributions(year=year),
    )


_CUBE_FILE_PATTERN = re.compile(r"contrib_cube_(\d{2})")
_COLOR_FILE_PATTERN = re.compile(r".*_color(\d+)$")


def _cube_month_from_path(path: Path) -> int | None:
    """Return the month encoded in a ``contrib_cube_MM`` filename."""

    match = _CUBE_FILE_PATTERN.match(path.stem)
    if not match:
        return None
    try:
        month = int(match.group(1))
    except ValueError:
        return None
    return month if 1 <= month <= 12 else None


def _color_index_from_path(path: Path) -> int | None:
    """Return the color index encoded in a ``*_colorN`` filename."""

    match = _COLOR_FILE_PATTERN.match(path.stem)
    if not match:
        return None
    index = int(match.group(1))
    return index if index > 0 else None


def _cleanup_gridfinity_cube_outputs(
    year_dir: Path, active_months: set[int], *, remove_stls: bool
) -> None:
    """Delete stale Gridfinity cube files that no longer match current data."""

    for scad_path in year_dir.glob("contrib_cube_*.scad"):
        month = _cube_month_from_path(scad_path)
        if month is None or month in active_months:
            continue
        scad_path.unlink(missing_ok=True)
        MetadataWriter.unlink_for(scad_path)
    for stl_path in year_dir.glob("contrib_cube_*.stl"):
        month = _cube_month_from_path(stl_path)
        if month is None:
            continue
        if remove_stls or month not in active_months:
            stl_path.unlink(missing_ok=True)


def _cleanup_color_outputs(
    base_output: Path, color_groups: int, *, stl_requested: bool
) -> None:
    """Remove stale multi-color SCAD/STL files after rendering.

    When ``color_groups`` is ``0`` every ``*_colorN`` file is deleted so
    single-color runs clear leftover multi-color artifacts.
    """

    if color_groups < 0:
        return

    pattern = f"{base_output.name}_color*.scad"
    for scad_path in base_output.parent.glob(pattern):
        index = _color_index_from_path(scad_path)
        if index is None:
            continue
        if color_groups == 0 or index > color_groups:
            scad_path.unlink(missing_ok=True)
            MetadataWriter.unlink_for(scad_path)

    stl_pattern = f"{base_output.name}_color*.stl"
    for stl_path in base_output.parent.glob(stl_pattern):
        if not stl_requested or color_groups == 0:
            stl_path.unlink(missing_ok=True)
            continue
        index = _color_index_from_path(stl_path)
        if index is None:
            continue
        if index > color_groups:
            stl_path.unlink(missing_ok=True)


def _previous_monthly_stl_path(output_path: Path) -> Path | None:
    """Return the STL recorded in the output metadata, if any."""

    metadata_path = output_path.with_suffix(".json")
    try:
        data = json.loads(metadata_path.read_text())
    except (FileNotFoundError, json.JSONDecodeError):
        return None

    stl_value = data.get("stl")
    if not stl_value:
        return None

    return Path(stl_value)


def _remove_previous_monthly_stl(output_path: Path) -> None:
    """Delete the STL recorded in ``output_path`` metadata if present."""

    previous = _previous_monthly_stl_path(output_path)
    if previous is None:
        return

    previous.unlink(missing_ok=True)


# Backwards compatibility for callers still using the previous helper name.
_cleanup_unused_color_outputs = _cleanup_color_outputs


def _cleanup_calendar_directories(year_dir: Path, keep_slug: str) -> None:
    for path in year_dir.glob("monthly-*"):
        if path.name == keep_slug:
            continue
        if path.is_dir():
            shutil.rmtree(path, ignore_errors=True)
        else:
            path.unlink(missing_ok=True)


def main(argv: list[str] | None = None):
    parser = argparse.ArgumentParser(
        description="Generate 3D GitHub contribution charts",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument("username", help="GitHub username")
    parser.add_argument(
        "--token",
        help=(
            "GitHub API token (fallback order: --token value, GH_TOKEN, then GITHUB_TOKEN)"
        ),
    )
    parser.add_argument("--start-year", type=int, help="First year of contributions")
    parser.add_argument("--end-year", type=int, help="Last year of contributions")
    parser.add_argument(
        "--output", default="contributions.scad", help="Output .scad file"
    )
    parser.add_argument(
        "--months-per-row",
        type=int,
        default=12,
        help="Number of months displayed across each row",
    )
    parser.add_argument(
        "--calendar-days-per-row",
        type=int,
        default=None,
        help=(
            "Days per row in generated monthly calendars (defaults to match --months-per-row)"
        ),
    )
    parser.add_argument(
        "--stl",
        help="Optional output STL file (requires openscad)",
    )
    parser.add_argument(
        "--colors",
        type=int,
        choices=range(1, 6),
        default=1,
        help="Number of print colors (1-5)",
    )
    parser.add_argument(
        "--gridfinity-layouts",
        action="store_true",
        help="Generate Gridfinity baseplate layouts per year",
    )
    parser.add_argument(
        "--gridfinity-columns",
        type=int,
        default=6,
        help="Columns per Gridfinity baseplate row when layouts are generated",
    )
    parser.add_argument(
        "--gridfinity-cubes",
        action="store_true",
        help="Generate monthly Gridfinity cube stacks (SCAD; add --stl for STLs)",
    )
    parser.add_argument(
        "--baseplate-template",
        choices=["baseplate_2x6.scad", "baseplate_1x12.scad"],
        default="baseplate_2x6.scad",
        help="Bundled baseplate template to copy when generating multi-color outputs",
    )
    parser.add_argument(
        "--json",
        help="Optional run-level metadata summary file",
    )
    try:  # pragma: no cover - metadata lookup
        pkg_version = metadata.version("gitshelves")
    except metadata.PackageNotFoundError:  # pragma: no cover
        pkg_version = "0.0.0"
    parser.add_argument(
        "--version", action="version", version=f"%(prog)s {pkg_version}"
    )
    if argv is None:
        args = parser.parse_args()
    else:
        args = parser.parse_args(argv)

    if not hasattr(args, "calendar_days_per_row"):
        args.calendar_days_per_row = None

    if args.months_per_row <= 0:
        parser.error("--months-per-row must be positive")

    if args.gridfinity_columns <= 0:
        parser.error("--gridfinity-columns must be positive")

    if args.calendar_days_per_row is None:
        args.calendar_days_per_row = args.months_per_row

    if args.calendar_days_per_row <= 0:
        parser.error("--calendar-days-per-row must be positive")

    if not hasattr(args, "baseplate_template"):
        args.baseplate_template = "baseplate_2x6.scad"

    token = resolve_token(args.token)
    contribs = fetch_user_contributions(
        args.username,
        token=token,
        start_year=args.start_year,
        end_year=args.end_year,
    )
    start_year, end_year, counts, daily_counts = build_contribution_maps(
        contribs,
        args.start_year,
        args.end_year,
        determine_range=_determine_year_range,
    )

    metadata_writer = MetadataWriter(
        username=args.username,
        start_year=start_year,
        end_year=end_year,
        monthly_counts=counts,
        daily_counts=daily_counts,
        months_per_row=args.months_per_row,
        calendar_days_per_row=args.calendar_days_per_row,
        colors=args.colors,
        gridfinity_layouts=args.gridfinity_layouts,
        gridfinity_columns=args.gridfinity_columns,
        gridfinity_cubes=args.gridfinity_cubes,
        baseplate_template=args.baseplate_template,
    )

    output_path = Path(args.output)
    if not args.stl:
        _remove_previous_monthly_stl(output_path)

    render_yearly_stl = bool(args.stl)
    for year in range(start_year, end_year + 1):
        extras: list[str] = []
        calendar_slug = _calendar_slug(args.calendar_days_per_row)
        if args.gridfinity_layouts:
            months_in_year = 12
            rows = (
                months_in_year + args.gridfinity_columns - 1
            ) // args.gridfinity_columns
            footprint = f"{args.gridfinity_columns}\u00d7{rows} grid"
            layout_note = (
                f"- Gridfinity layout: {footprint} via `gridfinity_plate.scad`"
            )
            if args.stl:
                layout_note += " and `gridfinity_plate.stl`"
            layout_note += " (auto-generated)"
            extras.append(layout_note)
        if args.gridfinity_cubes:
            months_with_cubes = [
                month
                for month in range(1, 13)
                if blocks_for_contributions(counts.get((year, month), 0)) > 0
            ]
            if months_with_cubes:
                labels = ", ".join(month_abbr[m] for m in months_with_cubes)
                extras.append(f"- Gridfinity cubes: {labels} (SCAD + STL)")
            else:
                extras.append("- Gridfinity cubes: none generated (no contributions)")
        readme_path = write_year_readme(
            year,
            counts,
            extras=extras or None,
            include_baseplate_stl=render_yearly_stl,
            calendar_slug=calendar_slug,
        )
        year_dir = readme_path.parent
        _write_year_baseplate(year_dir, render_yearly_stl, metadata_writer, year)
        calendars = generate_monthly_calendar_scads(
            daily_counts, year, days_per_row=args.calendar_days_per_row
        )
        _cleanup_calendar_directories(year_dir, calendar_slug)
        calendar_dir = year_dir / calendar_slug
        calendar_dir.mkdir(parents=True, exist_ok=True)
        for month, text in calendars.items():
            slug = month_name[month].lower()
            scad_path = calendar_dir / f"{month:02d}_{slug}.scad"
            scad_path.write_text(text)
            print(f"Wrote {scad_path}")
            metadata_writer.write_scad(
                scad_path,
                kind="monthly-calendar",
                year=year,
                month=month,
                monthly_contributions=metadata_writer.monthly_contributions(
                    year=year, month=month
                ),
                daily_contributions=metadata_writer.daily_contributions(
                    year=year, month=month
                ),
            )
        layout_path = readme_path.parent / "gridfinity_plate.scad"
        layout_stl_path = layout_path.with_suffix(".stl")
        if args.gridfinity_layouts:
            layout_text = generate_gridfinity_plate_scad(
                counts, year, columns=args.gridfinity_columns
            )
            layout_path.write_text(layout_text)
            print(f"Wrote {layout_path}")
            if args.stl:
                scad_to_stl(str(layout_path), str(layout_stl_path))
                print(f"Wrote {layout_stl_path}")
            else:
                layout_stl_path.unlink(missing_ok=True)
            metadata_writer.write_scad(
                layout_path,
                kind="gridfinity-layout",
                stl_path=layout_stl_path if args.stl else None,
                year=year,
                monthly_contributions=metadata_writer.monthly_contributions(year=year),
                details={
                    "columns": args.gridfinity_columns,
                    "rows": rows,
                },
            )
        else:
            layout_path.unlink(missing_ok=True)
            layout_stl_path.unlink(missing_ok=True)
            MetadataWriter.unlink_for(layout_path)
        if args.gridfinity_cubes:
            year_dir = readme_path.parent
            generated_cube_months: set[int] = set()
            for month in range(1, 13):
                levels = blocks_for_contributions(counts.get((year, month), 0))
                cube_scad_path = year_dir / f"contrib_cube_{month:02d}.scad"
                cube_stl_path = cube_scad_path.with_suffix(".stl")
                if levels <= 0:
                    if cube_scad_path.exists():
                        cube_scad_path.unlink()
                        MetadataWriter.unlink_for(cube_scad_path)
                    if cube_stl_path.exists():
                        cube_stl_path.unlink()
                    continue
                generated_cube_months.add(month)
                cube_scad = generate_contrib_cube_stack_scad(levels)
                cube_scad_path.write_text(cube_scad)
                print(f"Wrote {cube_scad_path}")
                scad_to_stl(str(cube_scad_path), str(cube_stl_path))
                print(f"Wrote {cube_stl_path}")
                metadata_writer.write_scad(
                    cube_scad_path,
                    kind="gridfinity-cube",
                    stl_path=cube_stl_path,
                    year=year,
                    month=month,
                    monthly_contributions=metadata_writer.monthly_contributions(
                        year=year, month=month
                    ),
                    details={"levels": levels},
                )
            _cleanup_gridfinity_cube_outputs(
                year_dir,
                generated_cube_months,
                remove_stls=False,
            )
        else:
            year_dir = readme_path.parent
            for cube_scad_path in year_dir.glob("contrib_cube_*.scad"):
                if _cube_month_from_path(cube_scad_path) is not None:
                    cube_scad_path.unlink(missing_ok=True)
                    MetadataWriter.unlink_for(cube_scad_path)
            for cube_stl_path in year_dir.glob("contrib_cube_*.stl"):
                if _cube_month_from_path(cube_stl_path) is not None:
                    cube_stl_path.unlink(missing_ok=True)

    if args.colors == 1:
        scad_text = generate_scad_monthly(counts, months_per_row=args.months_per_row)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(scad_text)
        print(f"Wrote {output_path}")
        stl_path = None
        if args.stl:
            stl_path = Path(args.stl)
            stl_path.parent.mkdir(parents=True, exist_ok=True)
            scad_to_stl(str(output_path), str(stl_path))
            print(f"Wrote {stl_path}")
        metadata_writer.write_scad(
            output_path,
            kind="monthly",
            stl_path=stl_path,
            monthly_contributions=metadata_writer.monthly_contributions(),
        )
        base_output = output_path
        if base_output.suffix:
            base_output = base_output.with_suffix("")
        _cleanup_color_outputs(base_output, 0, stl_requested=bool(args.stl))
    else:
        _remove_previous_monthly_stl(output_path)
        if args.stl:
            Path(args.stl).unlink(missing_ok=True)
        output_path.with_suffix(".stl").unlink(missing_ok=True)
        output_path.unlink(missing_ok=True)
        MetadataWriter.unlink_for(output_path)
        level_scads = generate_scad_monthly_levels(
            counts, months_per_row=args.months_per_row
        )
        color_groups = min(args.colors, 4) if args.colors > 1 else 1
        grouped, level_mapping = group_scad_levels_with_mapping(
            level_scads, color_groups
        )
        if not grouped:
            grouped = {idx: SCAD_HEADER for idx in range(1, color_groups + 1)}
            level_mapping = {idx: [] for idx in range(1, color_groups + 1)}
        else:
            for idx in range(1, color_groups + 1):
                grouped.setdefault(idx, SCAD_HEADER)
                level_mapping.setdefault(idx, [])
        zero_comments = generate_zero_month_annotations(
            counts, months_per_row=args.months_per_row
        )
        base_output = output_path
        base_output.parent.mkdir(parents=True, exist_ok=True)
        if base_output.suffix:
            base_output = base_output.with_suffix("")
        base_stl = Path(args.stl) if args.stl else None
        if base_stl:
            base_stl.parent.mkdir(parents=True, exist_ok=True)
            if base_stl.suffix:
                base_stl = base_stl.with_suffix("")
        baseplate_path = base_output.with_name(f"{base_output.name}_baseplate.scad")
        try:
            baseplate_source = load_baseplate_scad(args.baseplate_template)
        except TypeError:
            baseplate_source = load_baseplate_scad()
        baseplate_path.write_text(baseplate_source)
        print(f"Wrote {baseplate_path}")
        baseplate_stl = None
        if base_stl:
            baseplate_stl = base_stl.with_name(f"{base_stl.name}_baseplate.stl")
            scad_to_stl(str(baseplate_path), str(baseplate_stl))
            print(f"Wrote {baseplate_stl}")
        else:
            baseplate_path.with_suffix(".stl").unlink(missing_ok=True)
        metadata_writer.write_scad(
            baseplate_path,
            kind="baseplate-template",
            stl_path=baseplate_stl,
            monthly_contributions=metadata_writer.monthly_contributions(),
            details={"template": args.baseplate_template},
        )
        for idx in sorted(grouped):
            text = grouped[idx]
            scad_path = base_output.with_name(f"{base_output.name}_color{idx}.scad")
            lines = text.splitlines()
            if zero_comments:
                if lines and lines[-1].strip():
                    lines.append("")
                lines.extend(zero_comments)
            scad_output = "\n".join(lines)
            scad_path.write_text(scad_output)
            print(f"Wrote {scad_path}")
            has_geometry = any(
                line.strip() and not line.lstrip().startswith("//") for line in lines
            )
            stl_path = None
            if base_stl:
                stl_path = base_stl.with_name(f"{base_stl.name}_color{idx}.stl")
            if base_stl and has_geometry:
                scad_to_stl(str(scad_path), str(stl_path))
                print(f"Wrote {stl_path}")
            elif stl_path and stl_path.exists():
                stl_path.unlink()
            metadata_writer.write_scad(
                scad_path,
                kind="monthly-color",
                stl_path=stl_path if base_stl and has_geometry else None,
                color_index=idx,
                levels=level_mapping.get(idx, []),
                monthly_contributions=metadata_writer.monthly_contributions(),
                details={
                    "has_geometry": has_geometry,
                    "zero_month_annotations": bool(zero_comments),
                },
            )

        _cleanup_color_outputs(base_output, color_groups, stl_requested=bool(base_stl))

    summary_path = getattr(args, "json", None)
    if summary_path:
        metadata_writer.write_run_summary(summary_path)

    # Restore canonical modules so downstream imports see the default implementations.
    sys.modules["gitshelves.scad"] = _scad
    sys.modules["gitshelves.fetch"] = _fetch


if __name__ == "__main__":
    main()
