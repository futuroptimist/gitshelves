from collections import defaultdict
import math
from dataclasses import dataclass
from typing import Dict, Iterable, Iterator, Tuple

HEADER = "// Generated by gitshelves"
BLOCK_SIZE = 10  # mm per block cube
SPACING = 12


def blocks_for_contributions(count: int) -> int:
    """Return the number of stacked blocks for a contribution count.

    Uses a logarithmic scale where 1 block represents 1-9 contributions,
    2 blocks represent 10-99 contributions, and so on. Zero or negative
    counts yield zero blocks.
    """
    if count <= 0:
        return 0

    return int(math.log10(count)) + 1


@dataclass(frozen=True)
class _BlockPosition:
    x: int
    y: int
    z: int
    year: int
    month: int
    level: int


def _iter_monthly_block_positions(
    contributions: Dict[Tuple[int, int], int], months_per_row: int
) -> Iterator[_BlockPosition]:
    """Yield ``_BlockPosition`` objects for monthly contributions."""
    if months_per_row <= 0:
        raise ValueError("months_per_row must be positive")
    if not contributions:
        return

    first_year = min(year for year, _ in contributions)
    last_year = max(year for year, _ in contributions)
    month_iter = (
        (year, month)
        for year in range(first_year, last_year + 1)
        for month in range(1, 13)
    )
    for idx, (year, month) in enumerate(month_iter):
        count = contributions.get((year, month), 0)
        for level in range(blocks_for_contributions(count)):
            col = idx % months_per_row
            row = idx // months_per_row
            x = col * SPACING
            y = row * SPACING
            z = level * BLOCK_SIZE
            yield _BlockPosition(x, y, z, year, month, level)


def _format_block(pos: _BlockPosition) -> str:
    return (
        f"translate([{pos.x}, {pos.y}, {pos.z}]) cube({BLOCK_SIZE}); "
        f"// {pos.year}-{pos.month:02}"
    )


def _iter_monthly_block_lines(
    contributions: Dict[Tuple[int, int], int], months_per_row: int
) -> Iterator[tuple[int, str]]:
    """Yield block level and formatted line for monthly contributions."""
    for pos in _iter_monthly_block_positions(contributions, months_per_row):
        yield pos.level, _format_block(pos)


def generate_scad(contributions: Iterable[int]) -> str:
    """Generate an OpenSCAD script for a sequence of daily contributions."""
    scad_lines = [HEADER]
    for idx, count in enumerate(contributions):
        x = idx * SPACING
        for level in range(blocks_for_contributions(count)):
            z = level * BLOCK_SIZE
            scad_lines.append(f"translate([{x}, 0, {z}]) cube({BLOCK_SIZE});")
    return "\n".join(scad_lines)


def generate_scad_monthly(
    contributions: Dict[Tuple[int, int], int], months_per_row: int = 12
) -> str:
    """Generate an OpenSCAD script from monthly contribution counts.

    The ``contributions`` mapping uses ``(year, month)`` tuples as keys. The
    months are arranged left-to-right in rows of ``months_per_row`` slots. Each
    slot contains a stack of blocks on a logarithmic scale, so a month with
    1‑9 contributions shows one block, 10‑99 contributions shows two blocks, and
    so on.
    """
    scad_lines = [HEADER]
    for _, line in _iter_monthly_block_lines(contributions, months_per_row):
        scad_lines.append(line)
    return "\n".join(scad_lines)


def generate_scad_monthly_levels(
    contributions: Dict[Tuple[int, int], int], months_per_row: int = 12
) -> Dict[int, str]:
    """Return OpenSCAD scripts grouped by block level.

    Each dictionary key corresponds to a logarithmic block level starting at 1.
    This allows printing different contribution magnitudes in separate colors.
    """
    levels: Dict[int, list[str]] = defaultdict(list)
    for level, line in _iter_monthly_block_lines(contributions, months_per_row):
        levels[level + 1].append(line)

    return {lvl: HEADER + "\n" + "\n".join(lines) for lvl, lines in levels.items()}


def _body_lines(scad_text: str) -> list[str]:
    """Return SCAD lines without the generated header."""
    return scad_text.splitlines()[1:]


def group_scad_levels(level_scads: Dict[int, str], groups: int) -> Dict[int, str]:
    """Combine level-specific SCAD snippets into ``groups`` color groups.

    ``groups`` is the number of distinct block colors and must be at least ``1``.
    Levels are distributed evenly across groups. Each output retains the
    standard header.
    """
    if groups < 1:
        raise ValueError("groups must be >= 1")

    if not level_scads:
        return {}

    if min(level_scads) < 1:
        raise ValueError("level keys must be >= 1")

    max_level = max(level_scads)
    levels_per_group = math.ceil(max_level / groups)
    grouped: Dict[int, list[str]] = defaultdict(list)
    for level, text in sorted(level_scads.items()):
        idx = (level - 1) // levels_per_group + 1
        grouped[idx].extend(_body_lines(text))
    return {idx: HEADER + "\n" + "\n".join(lines) for idx, lines in grouped.items()}


def scad_to_stl(scad_file: str, stl_file: str) -> None:
    """Convert ``scad_file`` to ``stl_file`` using the ``openscad`` CLI.

    If the current environment lacks an X display (``$DISPLAY`` is unset or
    empty), the command is automatically wrapped in ``xvfb-run`` when
    available. This mirrors the CI configuration and prevents ``openscad`` from
    exiting with code ``1`` on headless servers.
    """
    import os
    import shutil
    import subprocess

    if shutil.which("openscad") is None:
        raise FileNotFoundError("openscad not found")

    cmd = ["openscad", "-o", stl_file, scad_file]
    if not os.environ.get("DISPLAY"):
        if shutil.which("xvfb-run") is None:
            raise RuntimeError("xvfb-run required for headless rendering")
        cmd = [
            "xvfb-run",
            "--auto-servernum",
            "--server-args=-screen 0 1024x768x24",
        ] + cmd

    subprocess.run(cmd, check=True)
