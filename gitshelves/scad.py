from collections import defaultdict
import math
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, Iterator, Tuple
import calendar

HEADER = "// Generated by gitshelves"
BLOCK_SIZE = 10  # mm per block cube
SPACING = 12
GRIDFINITY_PITCH = 42  # mm between Gridfinity cells
GRIDFINITY_BASEPLATE_HEIGHT = 6  # mm
GRIDFINITY_UNIT_HEIGHT = 7  # mm per Gridfinity cube unit

GRIDFINITY_LIBRARY_ROOT = (
    Path(__file__).resolve().parent.parent / "openscad" / "lib" / "gridfinity-rebuilt"
)
GRIDFINITY_BASEPLATE_SCAD = (
    GRIDFINITY_LIBRARY_ROOT / "gridfinity-rebuilt-baseplate.scad"
)
GRIDFINITY_BIN_SCAD = GRIDFINITY_LIBRARY_ROOT / "gridfinity-rebuilt-bin.scad"


def blocks_for_contributions(count: int) -> int:
    """Return the number of stacked blocks for a contribution count.

    Uses a logarithmic scale where 1 block represents 1-9 contributions,
    2 blocks represent 10-99 contributions, and so on. Zero or negative
    counts yield zero blocks.
    """
    if count <= 0:
        return 0

    return int(math.log10(count)) + 1


@dataclass(frozen=True)
class _BlockPosition:
    x: int
    y: int
    z: int
    year: int
    month: int
    level: int


def _iter_monthly_block_positions(
    contributions: Dict[Tuple[int, int], int], months_per_row: int
) -> Iterator[_BlockPosition]:
    """Yield ``_BlockPosition`` objects for monthly contributions."""
    if months_per_row <= 0:
        raise ValueError("months_per_row must be positive")
    if not contributions:
        return

    first_year = min(year for year, _ in contributions)
    last_year = max(year for year, _ in contributions)
    month_iter = (
        (year, month)
        for year in range(first_year, last_year + 1)
        for month in range(1, 13)
    )
    for idx, (year, month) in enumerate(month_iter):
        count = contributions.get((year, month), 0)
        for level in range(blocks_for_contributions(count)):
            col = idx % months_per_row
            row = idx // months_per_row
            x = col * SPACING
            y = row * SPACING
            z = level * BLOCK_SIZE
            yield _BlockPosition(x, y, z, year, month, level)


def _format_block(pos: _BlockPosition) -> str:
    return (
        f"translate([{pos.x}, {pos.y}, {pos.z}]) cube({BLOCK_SIZE}); "
        f"// {pos.year}-{pos.month:02}"
    )


def _iter_monthly_block_lines(
    contributions: Dict[Tuple[int, int], int], months_per_row: int
) -> Iterator[tuple[int, str]]:
    """Yield block level and formatted line for monthly contributions."""
    for pos in _iter_monthly_block_positions(contributions, months_per_row):
        yield pos.level, _format_block(pos)


def generate_month_calendar_scad(
    daily_contributions: Dict[Tuple[int, int, int], int],
    year: int,
    month: int,
    days_per_row: int = 5,
) -> str:
    """Return a SCAD script visualising a single month's daily contributions."""

    if days_per_row <= 0:
        raise ValueError("days_per_row must be positive")

    days_in_month = calendar.monthrange(year, month)[1]
    lines = [HEADER]
    for day in range(1, days_in_month + 1):
        count = daily_contributions.get((year, month, day), 0)
        if count <= 0:
            continue
        idx = day - 1
        col = idx % days_per_row
        row = idx // days_per_row
        for level in range(blocks_for_contributions(count)):
            x = col * SPACING
            y = row * SPACING
            z = level * BLOCK_SIZE
            lines.append(
                (
                    f"translate([{x}, {y}, {z}]) cube({BLOCK_SIZE}); "
                    f"// {year}-{month:02}-{day:02}"
                )
            )

    return "\n".join(lines)


def generate_monthly_calendar_scads(
    daily_contributions: Dict[Tuple[int, int, int], int],
    year: int,
    days_per_row: int = 5,
) -> Dict[int, str]:
    """Return SCAD scripts for each month of ``year`` using daily data."""

    calendars: Dict[int, str] = {}
    for month in range(1, 13):
        calendars[month] = generate_month_calendar_scad(
            daily_contributions, year, month, days_per_row=days_per_row
        )
    return calendars


def generate_scad(contributions: Iterable[int]) -> str:
    """Generate an OpenSCAD script for a sequence of daily contributions."""
    scad_lines = [HEADER]
    for idx, count in enumerate(contributions):
        x = idx * SPACING
        for level in range(blocks_for_contributions(count)):
            z = level * BLOCK_SIZE
            scad_lines.append(f"translate([{x}, 0, {z}]) cube({BLOCK_SIZE});")
    return "\n".join(scad_lines)


def generate_scad_monthly(
    contributions: Dict[Tuple[int, int], int], months_per_row: int = 12
) -> str:
    """Generate an OpenSCAD script from monthly contribution counts.

    The ``contributions`` mapping uses ``(year, month)`` tuples as keys. The
    months are arranged left-to-right in rows of ``months_per_row`` slots. Each
    slot contains a stack of blocks on a logarithmic scale, so a month with
    1‑9 contributions shows one block, 10‑99 contributions shows two blocks, and
    so on.
    """
    scad_lines = [HEADER]
    for _, line in _iter_monthly_block_lines(contributions, months_per_row):
        scad_lines.append(line)
    return "\n".join(scad_lines)


def generate_scad_monthly_levels(
    contributions: Dict[Tuple[int, int], int], months_per_row: int = 12
) -> Dict[int, str]:
    """Return OpenSCAD scripts grouped by block level.

    Each dictionary key corresponds to a logarithmic block level starting at 1.
    This allows printing different contribution magnitudes in separate colors.
    """
    levels: Dict[int, list[str]] = defaultdict(list)
    for level, line in _iter_monthly_block_lines(contributions, months_per_row):
        levels[level + 1].append(line)

    return {lvl: HEADER + "\n" + "\n".join(lines) for lvl, lines in levels.items()}


def _body_lines(scad_text: str) -> list[str]:
    """Return SCAD lines without the generated header."""
    return scad_text.splitlines()[1:]


def group_scad_levels(level_scads: Dict[int, str], groups: int) -> Dict[int, str]:
    """Combine level-specific SCAD snippets into ``groups`` color groups.

    ``groups`` is the number of distinct block colors and must be at least ``1``.
    Levels are distributed evenly across groups except when four or more block
    colors are requested and contribution levels exceed the number of colors.
    In that case the highest magnitudes are appended to the final group so the
    accent color collects every level beyond the third, mirroring the
    documentation for ``--colors 5``. Each output retains the standard header.
    """
    if groups < 1:
        raise ValueError("groups must be >= 1")

    if not level_scads:
        return {}

    if min(level_scads) < 1:
        raise ValueError("level keys must be >= 1")

    ordered_levels = sorted(level_scads.items())
    total_groups = min(groups, len(ordered_levels))

    # ``--colors 5`` exposes four block colors. When contributions introduce more than
    # four logarithmic levels, documentation promises the accent color (group 4)
    # gathers every remaining high-magnitude level. Ensure the last group collects
    # level four and above so additional orders reuse the accent palette.
    if total_groups == 4 and len(ordered_levels) > total_groups:
        grouped_lines: Dict[int, list[str]] = {
            idx: [] for idx in range(1, total_groups + 1)
        }
        for index, (_, text) in enumerate(ordered_levels):
            if index < total_groups - 1:
                target = index + 1
            else:
                target = total_groups
            grouped_lines[target].extend(_body_lines(text))

        return {
            idx: HEADER + ("\n" + "\n".join(lines) if lines else "")
            for idx, lines in grouped_lines.items()
        }

    grouped: Dict[int, list[str]] = {}
    cursor = 0

    if total_groups >= 4 and len(ordered_levels) > total_groups:
        # Preserve the first three block levels as distinct colors and stack
        # every higher magnitude into the final accent color.
        for group_index in range(1, total_groups):
            _, text = ordered_levels[cursor]
            grouped[group_index] = _body_lines(text)
            cursor += 1
        remaining: list[str] = []
        for _, text in ordered_levels[cursor:]:
            remaining.extend(_body_lines(text))
        grouped[total_groups] = remaining
    else:
        base_size = len(ordered_levels) // total_groups
        extra = len(ordered_levels) % total_groups

        group_sizes = [
            base_size + (1 if idx < extra else 0) for idx in range(total_groups)
        ]

        for group_index, size in enumerate(group_sizes, start=1):
            lines: list[str] = []
            for _ in range(size):
                _, text = ordered_levels[cursor]
                lines.extend(_body_lines(text))
                cursor += 1
            grouped[group_index] = lines

    return {
        idx: HEADER + "\n" + "\n".join(lines) if lines else HEADER
        for idx, lines in grouped.items()
    }


def generate_gridfinity_plate_scad(
    contributions: Dict[Tuple[int, int], int],
    year: int,
    columns: int = 6,
) -> str:
    """Return a Gridfinity-compatible SCAD for ``year`` contributions.

    The generated script instantiates a Gridfinity baseplate sized to ``columns``
    columns per row and arranges 1×1×1 Gridfinity bins for each month's
    contributions. Contribution stacks are offset so they rest on top of the
    baseplate. ``columns`` must be positive.
    """

    if columns <= 0:
        raise ValueError("columns must be positive")

    months = [(month, contributions.get((year, month), 0)) for month in range(1, 13)]

    rows = max(1, math.ceil(len(months) / columns))

    missing_files = [
        str(path)
        for path in (GRIDFINITY_BASEPLATE_SCAD, GRIDFINITY_BIN_SCAD)
        if not path.exists()
    ]
    if missing_files:
        raise FileNotFoundError(
            "Gridfinity library not found; expected files: " + ", ".join(missing_files)
        )

    baseplate_include = GRIDFINITY_BASEPLATE_SCAD.as_posix()
    bin_include = GRIDFINITY_BIN_SCAD.as_posix()

    lines = [
        HEADER,
        f"use <{baseplate_include}>;",
        f"use <{bin_include}>;",
        "",
        f"grid_pitch = {GRIDFINITY_PITCH};",
        f"baseplate_height = {GRIDFINITY_BASEPLATE_HEIGHT};",
        f"cube_unit = {GRIDFINITY_UNIT_HEIGHT};",
        "",
        "module gridfinity_baseplate(grid_x = 1,",
        "                            grid_y = 1,",
        "                            u_height = 6,",
        "                            lip = true,",
        '                            magnet_style = "gridfinity_refine",',
        "                            magnets_corners_only = false,",
        "                            screw_holes = false) {",
        "    include_magnets = !magnets_corners_only;",
        "    gridfinityBaseplate([grid_x, grid_y],",
        "                        grid_pitch,",
        "                        [0, 0],",
        "                        0,",
        "                        bundle_hole_options(",
        '                            refined_hole = magnet_style == "gridfinity_refine",',
        "                            magnet_hole = include_magnets,",
        "                            screw_hole = screw_holes,",
        "                            crush_ribs = true,",
        "                            chamfer = true,",
        "                            supportless = false",
        "                        ),",
        "                        0,",
        "                        [0, 0]);",
        "}",
        "",
        "module contribution_stack(levels) {",
        "    for (level = [0:levels-1]) {",
        "        translate([0, 0, baseplate_height + level * cube_unit])",
        "            bin(ux = 1, uy = 1, uh = 1,",
        '                walls = 1.2, floor = 1.6, lid = "none",',
        "                magnet_pockets = false, stackable = true);",
        "    }",
        "}",
        "",
        f"grid_x = {columns};",
        f"grid_y = {rows};",
        "",
        "union() {",
        "    gridfinity_baseplate(grid_x = grid_x,",
        "                         grid_y = grid_y,",
        "                         u_height = baseplate_height,",
        "                         lip = true,",
        '                         magnet_style = "gridfinity_refine",',
        "                         magnets_corners_only = false,",
        "                         screw_holes = false);",
    ]

    for idx, (month, count) in enumerate(months):
        levels = blocks_for_contributions(count)
        if levels == 0:
            continue
        col = idx % columns
        row = idx // columns
        x = col * GRIDFINITY_PITCH
        y = row * GRIDFINITY_PITCH
        lines.append(
            (
                f"    translate([{x}, {y}, 0]) contribution_stack({levels}); "
                f"// {year}-{month:02} ({count} contributions)"
            )
        )

    lines.append("}")
    return "\n".join(lines)


def generate_contrib_cube_stack_scad(levels: int) -> str:
    """Return a Gridfinity cube stack SCAD for ``levels`` cubes."""

    if levels < 0:
        raise ValueError("levels must be >= 0")

    if not GRIDFINITY_BIN_SCAD.exists():
        raise FileNotFoundError(
            "Gridfinity bin library not found; expected file: " f"{GRIDFINITY_BIN_SCAD}"
        )

    bin_include = GRIDFINITY_BIN_SCAD.as_posix()
    lines = [
        HEADER,
        f"use <{bin_include}>;",
        "",
        "module contribution_cube() {",
        "    bin(",
        "        ux = 1, uy = 1, uh = 1,",
        '        walls = 1.2, floor = 1.6, lid = "none",',
        "        magnet_pockets = false, stackable = true);",
        "}",
        "",
        f"unit_height = {GRIDFINITY_UNIT_HEIGHT};",
        "",
        "module contribution_stack(levels) {",
        "    for (level = [0:levels-1]) {",
        "        translate([0, 0, level * unit_height]) contribution_cube();",
        "    }",
        "}",
        "",
        (
            f"contribution_stack({levels});"
            f" // {levels} cube{'s' if levels != 1 else ''}"
        ),
    ]
    if levels == 0:
        lines.append("// No contributions")
    return "\n".join(lines)


def scad_to_stl(scad_file: str, stl_file: str) -> None:
    """Convert ``scad_file`` to ``stl_file`` using the ``openscad`` CLI.

    If the current environment lacks an X display (``$DISPLAY`` is unset or
    empty), the command is automatically wrapped in ``xvfb-run`` when
    available. The STL is exported in binary format (``--export-format
    binstl``) to mirror the CI configuration and prevent ``openscad`` from
    exiting with code ``1`` on headless servers.
    """
    import os
    import shutil
    import subprocess

    if shutil.which("openscad") is None:
        raise FileNotFoundError("openscad not found")

    cmd = ["openscad", "-o", stl_file, "--export-format", "binstl", scad_file]
    if not os.environ.get("DISPLAY"):
        if shutil.which("xvfb-run") is None:
            raise RuntimeError("xvfb-run required for headless rendering")
        cmd = [
            "xvfb-run",
            "--auto-servernum",
            "--server-args=-screen 0 1024x768x24",
        ] + cmd

    subprocess.run(cmd, check=True)
