<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gitshelves Viewer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #controls { position: fixed; top: 0; left: 0; background: #fff8; padding: 8px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/loaders/STLLoader.js"></script>
</head>
<body>
<div id="controls">
  <input type="file" id="files" multiple />
  <label>Colors
    <select id="colorCount">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
    </select>
  </label>
  <span id="detectedColors">Detected block colors: 0</span>
</div>
<script>
const palette = [0x1f77b4, 0xff7f0e, 0x2ca02c, 0xd62728, 0x9467bd];
const accentIndex = palette.length - 1;
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f0f0);
const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
camera.position.set(120, 120, 120);
const controls = new THREE.OrbitControls(camera, renderer.domElement);
const loader = new THREE.STLLoader();
const colorCount = document.getElementById('colorCount');
const detectedColors = document.getElementById('detectedColors');
const meshRegistry = [];

function applyColorSelection() {
  if (!colorCount) return;
  const maxColors = parseInt(colorCount.value, 10) || 1;
  meshRegistry.forEach(({ mesh, colorIndex }) => {
    mesh.visible = colorIndex === 0 || colorIndex <= maxColors;
  });
}

function clearMeshes() {
  scene.children.filter(o => o.isMesh).forEach(o => scene.remove(o));
  meshRegistry.length = 0;
}
function loadFiles(list) {
  clearMeshes();
  const files = Array.from(list || []);
  if (!files.length) {
    if (detectedColors) {
      detectedColors.textContent = 'Detected block colors: 0';
    }
    if (colorCount) {
      colorCount.innerHTML = '<option value="1">1</option>';
      colorCount.value = '1';
    }
    return;
  }
  const stls = [];
  for (const file of files) {
    let colorIndex = 0;
    const colorMatch = file.name.match(/color(\d+)/i);
    const levelMatch = file.name.match(/level(\d+)/i);
    if (colorMatch) colorIndex = parseInt(colorMatch[1], 10);
    else if (levelMatch) colorIndex = parseInt(levelMatch[1], 10);
    if (/baseplate/i.test(file.name)) colorIndex = 0;
    stls.push({ file, colorIndex });
  }
  const maxColorIndex = stls.reduce(
    (max, item) => (item.colorIndex > max ? item.colorIndex : max),
    0,
  );
  const blockColors = new Set(stls.map(item => item.colorIndex).filter(index => index > 0));
  const baseplateLoaded = stls.some(({ file }) => /baseplate/i.test(file.name));
  const blockColorCount = blockColors.size;
  if (detectedColors) {
    const plural = blockColorCount === 1 ? '' : 's';
    const baseplateSuffix = baseplateLoaded ? ' + baseplate' : '';
    detectedColors.textContent = `Detected ${blockColorCount} block color${plural}${baseplateSuffix}`;
  }
  if (colorCount) {
    const detected = Math.max(maxColorIndex, 1);
    const values = Array.from({ length: detected }, (_, idx) => String(idx + 1));
    const existing = Array.from(colorCount.options).map(opt => opt.value);
    const differs =
      existing.length !== values.length ||
      existing.some((value, idx) => value !== values[idx]);
    if (differs) {
      colorCount.innerHTML = values
        .map(value => `<option value="${value}">${value}</option>`)
        .join('');
    }
    const defaultValue = maxColorIndex > 0 ? String(maxColorIndex) : '1';
    colorCount.value = values.includes(defaultValue)
      ? defaultValue
      : values[values.length - 1] ?? '1';
  }
  stls.forEach(({ file, colorIndex }) => {
    const reader = new FileReader();
    reader.onload = e => {
      const geo = loader.parse(e.target.result);
      const paletteIndex = colorIndex > 0
        ? Math.min(colorIndex, accentIndex)
        : 0;
      const mat = new THREE.MeshPhongMaterial({ color: palette[paletteIndex] });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.name = file.name;
      scene.add(mesh);
      meshRegistry.push({ mesh, colorIndex });
      applyColorSelection();
    };
    reader.readAsArrayBuffer(file);
  });
}
if (colorCount) {
  colorCount.addEventListener('change', applyColorSelection);
}
document.getElementById('files').addEventListener('change', e => loadFiles(e.target.files));
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(1, 1, 1).normalize();
scene.add(light);
const ambient = new THREE.AmbientLight(0xffffff, 0.2);
scene.add(ambient);
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
